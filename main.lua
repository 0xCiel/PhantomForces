local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'; local L = loadstring(game:HttpGet(repo .. 'Library.lua'))(); local TM = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))(); local SM = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))(); local W = L:CreateWindow({Title = 'Ruby | Phantom Forces | discord.gg/cielbasement', Center = true, AutoShow = true, TabPadding = 8, MenuFadeTime = 0.2}); local T = {Main = W:AddTab('Main'), ['UI Settings'] = W:AddTab('UI Settings')}; local A = T.Main:AddLeftGroupbox('Aimbot'); local E = T.Main:AddRightGroupbox('ESP'); local M = T.Main:AddLeftGroupbox('Misc'); local p = game:GetService("Players"); local t = game:GetService("Teams"); local r = game:GetService("RunService"); local c = workspace.CurrentCamera; local u = game:GetService("UserInputService"); local s = game:GetService("TweenService"); local v = {a = {on = false, smooth = 0.3, fov = 100, show = false, wall = false, auto = true, dist = 500, click = true, key = "MB2"}, e = {on = true, name = true, dist = true, team = true, max = 500, size = 14, color = Color3.fromRGB(255, 255, 255), outline = true, fov = false, snap = true, scolor = Color3.fromRGB(255, 50, 50)}};local x = {}; local f = Drawing.new("Circle"); local n = Instance.new("NumberValue"); n.Value = v.a.smooth; local h = false; local g = nil; local o = {}; f.Visible = v.a.show; f.Color = Color3.fromRGB(255, 255, 255); f.Thickness = 1.5; f.Filled = false; f.Transparency = 1; f.Radius = v.a.fov; f.Position = Vector2.new(c.ViewportSize.X / 2, c.ViewportSize.Y / 2); c:GetPropertyChangedSignal("ViewportSize"):Connect(function() f.Position = Vector2.new(c.ViewportSize.X / 2, c.ViewportSize.Y / 2); end); local function y() local l = {} for _, b in ipairs(workspace.Players:GetChildren()) do for _, d in ipairs(b:GetChildren()) do if d:IsA("Model") then table.insert(l, d) end end end return l end local function z(d) if not v.e.team then return true end local k = p.LocalPlayer.Team local m = d:FindFirstChildWhichIsA("Folder") and d:FindFirstChildWhichIsA("Folder"):FindFirstChildOfClass("MeshPart") if not m then return false end local j = m.BrickColor.Name if j == "Black" and k.Name == "Phantoms" then return false elseif j ~= "Black" and k.Name == "Ghosts" then return false end return true end local function q(d) for _, b in d:GetChildren() do if b:IsA("BasePart") then local i = b:FindFirstChildOfClass("SpecialMesh") if i and i.MeshId == "rbxassetid://6179256256" then return b end end end return nil end local function w(d, a) for _, b in d:GetChildren() do if b:IsA("BasePart") then local i = b:FindFirstChildOfClass("SpecialMesh") if i and i.MeshId == "rbxassetid://4049240078" then return b end end end return nil end local function C(d) if x[d] then return end x[d] = {n = Drawing.new("Text"), di = Drawing.new("Text"), sl = Drawing.new("Line"), b = Drawing.new("Square"), o = Drawing.new("Square")} local e = x[d] for _, t in pairs({e.n, e.di}) do t.Size = v.e.size t.Color = v.e.color t.Outline = v.e.outline t.Center = true t.Visible = false end e.n.Text = d.Name e.di.Text = math.floor(0) .. " studs" e.sl.Visible = false e.sl.Color = v.e.scolor e.sl.Thickness = 1 e.b.Visible = false e.b.Color = v.e.color e.b.Thickness = 1 e.b.Filled = false e.o.Visible = false e.o.Color = Color3.fromRGB(0, 0, 0) e.o.Thickness = 1 e.o.Filled = false end local function D(d) if not x[d] then return end local he = q(d) local to = w(d, "Torso") if not he or not to then return end local e = x[d] local p, s = c:WorldToViewportPoint(he.Position) if s then local di = (he.Position - c.CFrame.Position).Magnitude if di > v.e.max then for _, dr in pairs(e) do dr.Visible = false end return end if v.e.fov then local sc = Vector2.new(c.ViewportSize.X / 2, c.ViewportSize.Y / 2) local sp = Vector2.new(p.X, p.Y) if (sp - sc).Magnitude > f.Radius then for _, dr in pairs(e) do dr.Visible = false end return end end local sp = Vector2.new(p.X, p.Y - 50) local sc = 1000 / (c.CFrame.Position - to.Position).Magnitude * 80 / c.FieldOfView local bs = Vector2.new(math.round(3 * sc), math.round(4 * sc)) local bp = Vector2.new(p.X - bs.X / 2, p.Y - bs.Y / 2) e.b.Position = bp e.b.Size = bs e.b.Visible = true e.o.Position = bp - Vector2.new(1, 1) e.o.Size = bs + Vector2.new(2, 2) e.o.Visible = true e.n.Position = bp + Vector2.new(bs.X / 2, -30) e.n.Visible = v.e.name e.di.Text = math.floor(di) .. " studs" e.di.Position = bp + Vector2.new(bs.X / 2, -15) e.di.Visible = v.e.dist if v.e.snap then e.sl.From = Vector2.new(c.ViewportSize.X/2, c.ViewportSize.Y) e.sl.To = Vector2.new(p.X, p.Y) e.sl.Visible = true else e.sl.Visible = false end else for _, dr in pairs(e) do dr.Visible = false end end end local function R(d) if not x[d] then return end for _, dr in pairs(x[d]) do dr:Remove() end x[d] = nil end local function S() if not v.e.on then return end for _, d in ipairs(y()) do if z(d) then C(d) D(d) else R(d) end end for d in pairs(x) do if not d:IsDescendantOf(workspace.Players) then R(d) end end end local function F() local cp = nil local sd = math.huge local sc = Vector2.new(c.ViewportSize.X / 2, c.ViewportSize.Y / 2) for _, d in ipairs(y()) do if d:IsDescendantOf(workspace.Ignore.DeadBody) then continue end if not z(d) then continue end local he = q(d) if he then local pp, s = c:WorldToViewportPoint(he.Position) if s then local sp = Vector2.new(pp.X, pp.Y) local dc = (sp - sc).Magnitude local di = (he.Position - c.CFrame.Position).Magnitude if v.a.dist > 0 and di > v.a.dist then continue end if v.a.show and dc > f.Radius then continue end if dc < sd then cp = he sd = dc end end end end return cp end local function V(p) if not v.a.wall then return true end local ra = Ray.new(c.CFrame.Position, (p.Position - c.CFrame.Position).unit * 1000) local hp = workspace:FindPartOnRay(ra, p.LocalPlayer.Character, false, true) return hp == p end local function B() if not g then return end if not g:IsDescendantOf(workspace) then g = nil return end local pp, s = c:WorldToViewportPoint(g.Position) if s then local ml = u:GetMouseLocation() local tp = Vector2.new(pp.X, pp.Y) local de = (tp - ml) * n.Value if de.Magnitude > 1 then mousemoverel(de.X, de.Y) end end end local function U(se) local ti = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out) local tw = s:Create(n, ti, {Value = se}) tw:Play() end local function O() local m = workspace:FindFirstChild("Map") if not m then return end for _, i in ipairs(m:GetDescendants()) do if i:IsA("BasePart") or i:IsA("UnionOperation") or i:IsA("MeshPart") then o[i] = {m = i.Material, r = i.Reflectance, s = i.CastShadow, t = i:FindFirstChild("TextureId") and i.TextureId or nil} i.Material = Enum.Material.SmoothPlastic i.Reflectance = 0 i.CastShadow = false if i:IsA("MeshPart") and i:FindFirstChild("TextureId") then i.TextureId = "" end end end end local function P() local m = workspace:FindFirstChild("Map") if not m then return end for _, i in ipairs(m:GetDescendants()) do if o[i] then i.Material = o[i].m i.Reflectance = o[i].r i.CastShadow = o[i].s if i:IsA("MeshPart") and i:FindFirstChild("TextureId") then i.TextureId = o[i].t or "" end end end end local ec = r.RenderStepped:Connect(S) local ic, oc, ac local function ToggleAimbot(st) if st then ic = u.InputBegan:Connect(function(i) if i.UserInputType == Enum.UserInputType.Keyboard and i.KeyCode.Name == v.a.key or i.UserInputType == Enum.UserInputType.MouseButton1 and v.a.key == "MB1" or i.UserInputType == Enum.UserInputType.MouseButton2 and v.a.key == "MB2" then h = true g = F() end end) oc = u.InputEnded:Connect(function(i) if i.UserInputType == Enum.UserInputType.Keyboard and i.KeyCode.Name == v.a.key or i.UserInputType == Enum.UserInputType.MouseButton1 and v.a.key == "MB1" or i.UserInputType == Enum.UserInputType.MouseButton2 and v.a.key == "MB2" then h = false g = nil end end) ac = r.RenderStepped:Connect(function() if h then if v.a.auto or not g then g = F() end if g and g:IsDescendantOf(workspace) then if V(g) then B() end else g = nil end end end) else h = false g = nil if ic then ic:Disconnect() end if oc then oc:Disconnect() end if ac then ac:Disconnect() end end end; A:AddToggle('Aimbot', {Text = 'Enabled', Default = v.a.on, Tooltip = 'Toggle the Aimbot', Callback = function(st) ToggleAimbot(st) v.a.on = st end}); A:AddSlider('Smoothness', {Text = 'Smoothness', Min = 0.1, Max = 1.5, Default = v.a.smooth, Rounding = 1, Callback = function(va) v.a.smooth = va U(va) end}); A:AddToggle('ShowFOV', {Text = 'Show FOV', Default = v.a.show, Tooltip = 'Display the FOV circle', Callback = function(st) v.a.show = st f.Visible = st end}); A:AddSlider('FOV', {Text = 'FOV Size', Min = 50, Max = 300, Rounding = 1, Default = v.a.fov, Callback = function(va) v.a.fov = va f.Radius = va end}); A:AddToggle('WallCheck', {Text = 'Wall Check', Default = v.a.wall, Tooltip = 'Toggle wall check for Aimbot', Callback = function(st) v.a.wall = st end}); A:AddToggle('AutoSwitch', {Text = 'Auto Switch', Default = v.a.auto, Tooltip = 'Automatically switch targets', Callback = function(st) v.a.auto = st end}); A:AddDropdown('AimbotKey', {Text = 'Aimbot Key', Values = {'LeftShift', 'LeftControl', 'MB1', 'MB2'}, Default = 4, Tooltip = 'Key to activate Aimbot', Callback = function(va) v.a.key = va end}); A:AddSlider('MaxDist', {Text = 'Max Distance', Min = 50, Max = 1000, Default = v.a.dist, Rounding = 0, Callback = function(va) v.a.dist = va end}); E:AddToggle('ESP', {Text = 'Enabled', Default = v.e.on, Tooltip = 'Toggle ESP functionality', Callback = function(st) v.e.on = st if not st then for d in pairs(x) do R(d) end end end}); E:AddToggle('Names', {Text = 'Names', Default = v.e.name, Tooltip = 'Display player names', Callback = function(st) v.e.name = st end}); E:AddToggle('Distance', {Text = 'Distance', Default = v.e.dist, Tooltip = 'Display player distances', Callback = function(st) v.e.dist = st end}); E:AddToggle('TeamCheck', {Text = 'Team Check', Default = v.e.team, Tooltip = 'Enable team check for ESP', Callback = function(st) v.e.team = st end}); E:AddToggle('VisibleOnly', {Text = 'Visible Only', Default = v.e.fov, Tooltip = 'Show only visible players', Callback = function(st) v.e.fov = st end}); E:AddToggle('SnapLines', {Text = 'Snap Lines', Default = v.e.snap, Tooltip = 'Draw snap lines to players', Callback = function(st) v.e.snap = st end}); E:AddToggle('BoxESP', {Text = 'Box ESP', Default = true, Tooltip = 'Display box ESP', Callback = function(st) for _, e in pairs(x) do if e.b then e.b.Visible = st e.o.Visible = st end end end}); E:AddSlider('ESPDist', {Text = 'Max Distance', Min = 50, Max = 1000, Default = v.e.max, Rounding = 0, Callback = function(va) v.e.max = va end}); E:AddSlider('TextSize', {Text = 'Text Size', Min = 8, Max = 24, Default = v.e.size, Rounding = 1, Callback = function(va) v.e.size = va for _, e in pairs(x) do pcall(function() e.n.Size = va e.di.Size = va end) end end}); E:AddLabel('TextColor'):AddColorPicker('TextColor', {Default = v.e.color, Tooltip = 'Pick a color for the ESP text', Callback = function(co) v.e.color = co for _, e in pairs(x) do e.n.Color = co e.di.Color = co end end}); E:AddLabel('SnapColor'):AddColorPicker('SnapColor', {Default = v.e.scolor, Tooltip = 'Pick a color for snap lines', Callback = function(co) v.e.scolor = co for _, e in pairs(x) do if e.sl then e.sl.Color = co end end end}); M:AddToggle('Optimize', {Text = 'Optimize Map', Default = false, Tooltip = 'Optimize map performance', Callback = function(st) if st then O() else P() end end}); L:OnUnload(function() print("Unloaded!") L.Unloaded = true end); local MenuGroup = T["UI Settings"]:AddLeftGroupbox("Menu"); MenuGroup:AddButton("Unload", function() L:Unload() end); MenuGroup:AddLabel("Menu bind"):AddKeyPicker("MenuKeybind", {Default = "End", NoUI = true, Text = "Menu keybind"}); L.ToggleKeybind = Options.MenuKeybind; TM:SetLibrary(L); SM:SetLibrary(L); SM:IgnoreThemeSettings(); TM:SetFolder('RubyPF'); SM:SetFolder('RubyPF/config'); SM:BuildConfigSection(T["UI Settings"]); TM:ApplyToTab(T["UI Settings"]); SM:LoadAutoloadConfig();
